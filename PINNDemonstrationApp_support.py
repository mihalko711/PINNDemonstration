#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Dec 25, 2024 03:00:07 AM +03  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

from sympy import false

from MyPINN import MyPINN1D,MyPINN2D,tf,plt,np

import PINNDemonstrationApp

_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top2, _w2
    _top2 = root
    _w2 = PINNDemonstrationApp.mainWnd(_top2)
    # Creates a toplevel widget.
    global _top3, _w3
    _top3 = tk.Toplevel(root)
    _w3 = PINNDemonstrationApp.Problem1(_top3)
    _top3.protocol("WM_DELETE_WINDOW", prevent_closing_1)
    _top3.withdraw()
    # Creates a toplevel widget.
    global _top4, _w4
    _top4 = tk.Toplevel(root)
    _w4 = PINNDemonstrationApp.Problem2(_top4)
    _top4.protocol("WM_DELETE_WINDOW", prevent_closing_2)
    _top4.withdraw()
    root.mainloop()


    global epochs1, epochs2, batch_size1,batch_size2,info_interval1, info_interval2
    global pinn1D, pinn2D,created1,created2
    created1 = False
    created2 = False

def batch_size_1_cnhg(*args):
    _w3.batch_size_1_info.configure(text=f'{int(_w3.batch_size_1_scale.get())}')
    if _debug:
        print('PINNDemonstrationApp_support.batch_size_1_cnhg')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def batch_size_2_chng(*args):
    _w4.batch_size_2_info.configure(text=f'{int(_w4.batch_size_2_scale.get())}')
    if _debug:
        print('PINNDemonstrationApp_support.batch_size_2_chng')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def create_model_1(*args):
    global created1,pinn1D
    try:
        f1 = eval('lambda x:' + _w3.f_1_input.get())
        q1 = eval('lambda x:' + _w3.q_1_input.get())
        k1 = eval('lambda x:' + _w3.k_1_input.get())
        a_1 = float(_w3.a_1_input.get())
        b_1 = float(_w3.b_1_input.get())
        u_a_1 = float(_w3.u_a_1_input.get())
        u_b_1 = float(_w3.u_b_1_input.get())
        pinn1D = MyPINN1D(u_a_1,u_b_1,k1,q1,f1,tf.convert_to_tensor([a_1,b_1]))
        _w3.list_report_1.delete(0,tk.END)
        _w3.list_report_1.insert(tk.END,f'Модель создана с параметрами: a = {a_1}, b = {b_1}, u(a) = {u_a_1}, u(b) ={u_b_1}')
        created1 = True
    except Exception as e:
        _w3.list_report_1.delete(0, tk.END)
        _w3.list_report_1.insert(tk.END,
                                 f'Произошла ошибка при построении модели: {e}')


    if _debug:
        print('PINNDemonstrationApp_support.create_model_1')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def create_model_2(*args):
    global created2, pinn2D
    try:
        f2 = eval('lambda x,t:' + _w4.f_2_input.get())
        g2 = eval('lambda x,t:' + _w4.g_2_input.get())
        g22 = eval('lambda x,t:' + _w4.g_22_input.get())
        v1 = eval('lambda x:' + _w4.v_1_input.get())
        v2 = eval('lambda x:' + _w4.v_2_input.get())
        a_2 = float(_w4.a_2_input.get())
        b_2 = float(_w4.b_2_input.get())
        c_2 = float(_w4.c_2_input.get())
        d_2 = float(_w4.d_2_input.get())
        pinn2D = MyPINN2D(g2,g22,v1,v2,f2,tf.convert_to_tensor([a_2,b_2]),tf.convert_to_tensor([c_2,d_2]))
        _w4.list_report_2.delete(0, tk.END)
        _w4.list_report_2.insert(tk.END,
                                 f'Модель создана с параметрами: a = {a_2}, b = {b_2}, c = {c_2}, d = {d_2}')
        created2 = True
    except Exception as e:
        _w4.list_report_2.delete(0, tk.END)
        _w4.list_report_2.insert(tk.END,
                                 f'Произошла ошибка при построении модели: {e}')
    if _debug:
        print('PINNDemonstrationApp_support.create_model_2')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def epochs_1_chng(*args):
    _w3.epochs_1_info.configure(text=f'{int(_w3.epochs_1_scale.get())}')
    if _debug:
        print('PINNDemonstrationApp_support.epochs_1_chng')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def epochs_2_chng(*args):
    _w4.epochs_2_info.configure(text=f'{int(_w4.epochs_2_scale.get())}')
    if _debug:
        print('PINNDemonstrationApp_support.epochs_2_chng')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def exit_event(*args):
    root.destroy()
    if _debug:
        print('PINNDemonstrationApp_support.exit_event')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def go_to_problem1(*args):
    _top3.deiconify()
    if _debug:
        print('PINNDemonstrationApp_support.go_to_problem1')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def go_to_problem2(*args):
    _top4.deiconify()
    if _debug:
        print('PINNDemonstrationApp_support.go_to_problem2')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def interval_1_chng(*args):
    _w3.interval_1_info.configure(text=f'{int(_w3.info_int_1_scale.get())}')
    if _debug:
        print('PINNDemonstrationApp_support.interval_1_chng')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def interval_2_chng(*args):
    _w4.interval_1_info.configure(text=f'{int(_w4.info_int_1_scale.get())}')
    if _debug:
        print('PINNDemonstrationApp_support.interval_2_chng')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def train_model_1(*args):
    global created1 ,pinn1D
    if created1:
        try:
            optimizer = tf.keras.optimizers.Adam(1e-3)
            pinn1D.compile(optimizer=optimizer)
            _w3.list_report_2.insert(tk.END, f'Модель успешно скомпилирована. Сейчас начнется тренировка с параметрами: \
                        epochs = {int(_w3.epochs_1_scale.get())}, batch_size = {int(_w3.batch_size_1_scale.get())},\
                        info interval = {int(_w3.info_int_1_scale.get())}')
        except Exception as e:
            _w3.list_report_1.insert(tk.END,f'Произошла ошибка:{e}')
    if _debug:
        print('PINNDemonstrationApp_support.train_model_1')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def train_model_2(*args):
    global created2, pinn2D
    if created2:
        try:
            optimizer = tf.keras.optimizers.Adam(1e-3)
            pinn2D.compile(optimizer=optimizer)
            _w4.list_report_2.insert(tk.END, f'Модель успешно скомпилирована. Сейчас начнется тренировка с параметрами: \
            epochs = {int(_w4.epochs_2_scale.get())}, batch_size = {int(_w4.batch_size_2_scale.get())},\
            info interval = {int(_w4.info_int_2_scale.get())}')
        except Exception as e:
            _w4.list_report_2.insert(tk.END, f'Произошла ошибка:{e}')
    if _debug:
        print('PINNDemonstrationApp_support.train_model_2')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def prevent_closing_1():
    _top3.withdraw()

def prevent_closing_2():
    _top4.withdraw()
if __name__ == '__main__':
    PINNDemonstrationApp.start_up()




